Для реализации был выбран язык программирования \emph{Haskell} и библиотека реактивного программирования \emph{reactive-banana}.
Для создания графического интерфейса приложения использовалась библиотека \emph{wxHaskell} (основанная на \emph{wxWidgets}).

\subsection{Модель}
Для моделирования игры было решено использовать две обрабатывающие сети: сеть управления моделированием
и сеть, непосредственно реализующую логику игры.

К первой сети подключены только кнопка <<Новая игра>> и переключатель <<Пауза>>.
Её задача --- запускать либо приостанавливать моделирование в сети логики,
а также генерировать событие <<начать новую игру>> (рис.~\ref{pic:global}).

Ко входам сети логики подключены следующие события:
\begin{itemize}
 \item {\tt enew} (генерируется управляющей сетью) --- начало новой игры;
 \item {\tt etimer} --- <<тик>> таймера (500мс);
 \item {\tt ekey} <нажатая клавиша> --- нажатие клавиши на клавиатуре.
\end{itemize}

Кроме того, генератором случайных чисел предоставлены следующие сигналы:
\begin{itemize}
 \item {\tt brndshape} --- форма следующего падающего блока;
 \item {\tt brndshapecolour} --- цвет следующего падающего блока.
\end{itemize}

Выводами сети логики являются следующие события:
\begin{itemize}
 \item необходимо перерисовать игровое поле;
 \item необходимо перерисовать изображение следущего на очереди блока.
\end{itemize}

Выходными сигналами сети логики являются:
\begin{itemize}
 \item функция, рисующая игровое поле на переданном ей контексте устройства вывода;
 \item функция, рисующая следующий на очереди блок на переданном ей контексте устройства вывода;
 \item текст, отображаемый в строке <<счёт>>.
\end{itemize}

Следущим событиям и сигналам не сопоставлены какие-либо входы или выходы; они являются
промежуточными и служат исключительно для упрощения кода:
\begin{itemize}
 \item {\tt eleft} --- нажата клавиша <<влево>>;
 \item {\tt eright} --- нажата клавиша <<вправо>>;
 \item {\tt erotcw} --- нажата клавиша <<повернуть по часовой стрелке>>;
 \item {\tt erotccw} --- нажата клавиша <<повернуть против часовой стрелки>>;
 \item {\tt espace} --- нажата клавиша <<пробел>>;
 \item {\tt etick} --- внутренний <<тик>> (может срабатывать чаще, чем <<тик>> таймера, чтобы ускорить падение блока);
 \item {\tt espawn} --- необходимо сгенерировать новый падающий блок;
 \item {\tt bnextshape} --- форма сладующего блока (представляет собой <<снимок>> входного сигнала {\tt brndshape},
 сделанный в момент генерации нового блока);
 \item {\tt bnextshapecolour} --- цвет следующего блока (аналогично {\tt bnextshape});
 \item {\tt bfalling} --- текущий падающий блок (его форма, цвет, позиция и поворот);
 \item {\tt bfield} --- текущее состоянее поля (список занятных клеток без учета падающего блока);
 \item {\tt ballcells} --- состояние поля с учетом падающего блока;
 \item {\tt ecollide} --- падающий блок столкнулся с дном стакана или частью блока, находящегося на поле;
 \item {\tt eclear} <кол-во заполненных рядов> --- целиком заполнился один или более горизонтальный ряд;
 \item {\tt efail} --- стакан переполнен;
 \item {\tt bdrawred} --- рисовать заполненные ячейки поля красным цветом (т.е. закончилась ли игра).
\end{itemize}

Рис.~\ref{pic:logics} демонстрирует связь между событиями и сигналами более наглядно.

\begin{figure}[p]
\includegraphics[angle=90,width=1\linewidth]{logics}
\caption{Сеть логики}
\label{pic:logics}
\end{figure}

\begin{figure}[p]
\centering

\includegraphics[width=1\linewidth]{global}
\caption{Общая структура}
\label{pic:global}

\vspace{5em}

\includegraphics{scr.png}
\caption{Снимок экрана}
\label{pic:scr}
\end{figure}