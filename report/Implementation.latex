\subsection{Инструменты}
Для реализации был выбран язык программирования \emph{Haskell}\citep{haskell} и библиотека реактивного программирования \emph{reactive-banana}\citep{reactive-banana}.
Для создания графического интерфейса приложения использовалась библиотека \emph{wxHaskell}\citep{wxHaskell} (основанная на \emph{wxWidgets}\citep{wxWidgets}).

\subsection{Модель}
При разработке с применением ФРП в первую очередь необходимо было построить модель, описывающую
игру, выделить требуемые события и сигналы, определить зависимости между ними.

В качестве примера рассмотрим игровой счет --- набранное игроком число очков. Удобно представить его
кусочно-постоянным целочисленным сигналом, изначально равным нулю. Увеличение значения сигнала
происходит при уничтожении ряда элементов на игровом поле. Разумно ввести событие
<<уничтожен ряд>>, которое, в свою очередь, зависит от события <<падающая фигура столкнулась с элементами,
находящимися на поле>> и происходит одновременно с последним, но только если в этот момент на поле можно найти
заполненный ряд.

Для описания конфигурации поля оказывается удобно ввести два сигнала: значением первого, также кусочно-постоянного,
является список заполненных клеток поля, изначально пустой
и затем изменяющийся, например, при наступлении события <<уничтожен ряд>>; значением же второго
сигнала являются форма, цвет и координаты падающего в данный момент блока --- к примеру, вертикальная координата,
содержащаяся в этом сигнале, уменьшается на единицу при наступлении события <<сработал таймер>>. Описанные два сигнала
тесно связаны между собой, поскольку при столкновении падающий блок добавляется к неподвижным элементами
игрового поля, а значение сигнала падающего блока изменяется таким образом, чтобы на поле стала падать новая
случайная фигура.

Полный список событий и сигналов приведен в подразделе~\ref{evsiglist}, а их взаимосвязь наглядно отражена
на рис.~\ref{pic:logics} и рис.~\ref{pic:global}.

\subsection{События и сигналы}
Для моделирования игры было принято решение использовать две сети обработки данных:
сеть управления моделированием и сеть, непосредственно реализующую логику игры.

\label{evsiglist}
К первой сети подключены только кнопка <<Новая игра>> и переключатель <<Пауза>>.
Её задача --- запускать либо приостанавливать моделирование в сети логики,
а также генерировать событие <<начать новую игру>> (рис.~\ref{pic:global}).

Ко входам сети логики подключены следующие события:
\begin{itemize}
 \item {\tt enew} (генерируется управляющей сетью) --- начало новой игры;
 \item {\tt etimer} --- <<тик>> таймера (500мс);
 \item {\tt ekey} <нажатая клавиша> --- нажатие клавиши на клавиатуре.
\end{itemize}

Кроме того, генератором случайных чисел предоставлены следующие сигналы:
\begin{itemize}
 \item {\tt brndshape} --- форма следующего падающего блока;
 \item {\tt brndshapecolour} --- цвет следующего падающего блока.
\end{itemize}

Выводами сети логики являются следующие события:
\begin{itemize}
 \item необходимо перерисовать игровое поле;
 \item необходимо перерисовать изображение следущего на очереди блока.
\end{itemize}

Выходными сигналами сети логики являются:
\begin{itemize}
 \item функция, рисующая игровое поле на переданном ей контексте устройства вывода;
 \item функция, рисующая следующий на очереди блок на переданном ей контексте устройства вывода;
 \item текст, отображаемый в строке <<счет>>.
\end{itemize}

Следущим событиям и сигналам не сопоставлены какие-либо входы или выходы; они являются
промежуточными и служат исключительно для упрощения кода:
\begin{itemize}
 \item {\tt eleft} --- нажата клавиша <<влево>>;
 \item {\tt eright} --- нажата клавиша <<вправо>>;
 \item {\tt erotcw} --- нажата клавиша <<повернуть по часовой стрелке>>;
 \item {\tt erotccw} --- нажата клавиша <<повернуть против часовой стрелки>>;
 \item {\tt espace} --- нажата клавиша <<пробел>>;
 \item {\tt etick} --- внутренний <<тик>> (может срабатывать чаще, чем <<тик>> таймера, чтобы ускорить падение блока);
 \item {\tt espawn} --- необходимо сгенерировать новый падающий блок;
 \item {\tt bnextshape} --- форма сладующего блока (представляет собой <<снимок>> входного сигнала {\tt brndshape},
 сделанный в момент генерации нового блока);
 \item {\tt bnextshapecolour} --- цвет следующего блока (аналогично {\tt bnextshape});
 \item {\tt bfalling} --- текущий падающий блок (его форма, цвет, позиция и поворот);
 \item {\tt bfield} --- текущее состоянее поля (список занятных клеток без учета падающего блока);
 \item {\tt ballcells} --- состояние поля с учетом падающего блока;
 \item {\tt ecollide} --- падающий блок столкнулся с дном стакана или частью блока, находящегося на поле;
 \item {\tt eclear} <кол-во заполненных рядов> --- целиком заполнился один или более горизонтальный ряд;
 \item {\tt efail} --- стакан переполнен;
 \item {\tt bdrawred} --- рисовать заполненные ячейки поля красным цветом (т.е. закончилась ли игра).
\end{itemize}

Рис.~\ref{pic:logics} демонстрирует связь между событиями и сигналами более наглядно.

\begin{figure}[p]
\includegraphics[angle=90,width=1\linewidth]{logics}
\caption{Сеть логики}
\label{pic:logics}
\end{figure}

\begin{figure}[p]
\centering

\includegraphics[width=1\linewidth]{global}
\caption{Общая структура}
\label{pic:global}

\vspace{5em}

\includegraphics{scr.png}
\caption{Снимок экрана}
\label{pic:scr}
\end{figure}
